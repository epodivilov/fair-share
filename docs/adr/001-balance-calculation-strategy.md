# 001. Balance Calculation Strategy

*   **Статус:** Принято
*   **Дата:** 2025-07-15

## Context

Для отображения итоговых долгов в группе необходимо выбрать способ расчета баланса. Существуют два основных подхода:
1.  **Предрасчет (Denormalization):** Хранить итоговый баланс в отдельной таблице (`Balances`) и обновлять его при каждом изменении (добавлении/удалении расхода или погашения).
2.  **Вычисление на лету (On-the-fly Calculation):** Не хранить итоговый баланс, а вычислять его каждый раз при запросе пользователя на основе исходных данных.

Проект является pet-проектом с небольшим ожидаемым количеством пользователей и расходов (согласно NFRs), приоритетом является простота поддержки и низкая стоимость.

## Decision

Мы выбираем подход **"Вычисление на лету"**. Итоговый баланс будет рассчитываться в реальном времени на стороне бэкенда при поступлении API-запроса. Расчет будет производиться путем агрегации данных из трех таблиц: `Expenses`, `ExpenseShares` и `Settlements`. Таблица для хранения итогового баланса создаваться не будет.

## Consequences

**Positive:**
*   **Простота логики записи:** Добавление расхода или погашения — это простая операция `INSERT`. Не нужно запускать сложные транзакции для обновления нескольких таблиц.
*   **Гарантия консистентности данных:** Баланс всегда актуален, так как считается из "сырых" данных. Исключены ошибки рассинхронизации между расходами и посчитанным балансом.
*   **Упрощение схемы БД:** Нам не нужна дополнительная таблица `Balances`.

**Negative:**
*   **Повышенная нагрузка на чтение:** При очень большом количестве расходов в одной группе (тысячи записей) расчет баланса может стать медленным и создавать нагрузку на БД.
*   **Сложность запроса:** SQL-запрос для вычисления баланса будет более сложным, чем простой `SELECT * FROM Balances`.

**Compromise:** Учитывая NFRs нашего MVP (мало пользователей, низкая нагрузка), плюсы в виде простоты и надежности значительно перевешивают минус в виде потенциальной проблемы с производительностью, которая на данном этапе маловероятна. Если в будущем производительность станет проблемой, это решение может быть пересмотрено (например, с помощью кэширования).
